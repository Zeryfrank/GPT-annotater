}
perplexity_annotate(my_data$text, instruction = "output the first few words of the text")
perplexity_annotate <- function(column,
instruction = "Be precise and concise.",
api_key = Sys.getenv("perplexity_key"),
model = "mistral-7b-instruct",
api_url = "https://api.perplexity.ai/chat/completions") {
columnname <- deparse(substitute(column))
filepath <- paste0("PerplexityOutput/", columnname, "/", model, "/")
if (!dir.exists(filepath)) {
dir.create(filepath, recursive = TRUE)
}
print(paste("Writing RDS file to:", filepath))
result_df <- data.frame(id = character(), response = character(), stringsAsFactors = FALSE)
for (i in seq_along(column)) {
to_annotate_id <- i
to_annotate_text <- gsub("(\n|\r)", " ", column[i])
authorization <- paste0("Bearer ", api_key)
attempt <- 1
max_attempts <- 3
success <- FALSE
while (!success && attempt <= max_attempts) {
try({
response <- httr::POST(
url = api_url,
httr::add_headers(`Content-Type` = "application/json", `Authorization` = authorization),
encode = "json",
body = list(
model = model,
messages = list(
list(role = "system", content = instruction),
list(role = "user", content = to_annotate_text)
)
),
httr::timeout(5000)  # Correctly placed inside the POST function call
)
success <- TRUE
response_content <- content(response, "parsed")
message_content <- response_content$choices[[1]]$message$content
write_rds_path <- paste0(filepath, to_annotate_id, ".rds")
saveRDS(response, write_rds_path)
Sys.sleep(0.6)
message(i, " of ", length(column))
message("status_id: ", to_annotate_id, "\n", "instruction: ", instruction, "\n", "text: ", to_annotate_text)
message("Perplexity: ", message_content, "\n")
result_df <- rbind(result_df, data.frame(id = to_annotate_id, response = message_content, stringsAsFactors = FALSE))
}, silent = FALSE)
if (!success) {
Sys.sleep(2)
attempt <- attempt + 1
}
}
if (!success) {
stop("Failed to fetch data after ", max_attempts, " attempts.")
}
}
return(result_df)
}
perplexity_annotate(my_data$text, instruction = "output the first few words of the text")
get_response <- function(dataframe,model) {
dataframename <- base::deparse(base::substitute(dataframe))
filepath <- stringr::str_c("LLMoutput/", dataframename, "/")
file_names <- base::list.files(filepath, full.names = TRUE)
gpt_labels <- base::rep(NA, base::length(file_names))
for (i in base::seq_along(file_names)){
response <- base::readRDS(file_names[i])
gpt_labels[i] <-
ifelse(
base::is.null(httr::content(response)$choices[[1]]$message$content),
NA, httr::content(response)$choices[[1]]$message$content)
}
gptoutput <- tibble::tibble(
id = stringr::str_replace(base::basename(file_names), "\\.rds$", ""),
relevant_gpt = gpt_labels
)
return(gptoutput)
}
OUTPUT <- get_response(my_data)
output <- perplexity_annotate(my_data$text, instruction = "output the first few words of the text")
View(output)
get_response <- function(dataframe,model) {
dataframename <- base::deparse(base::substitute(dataframe))
filepath <- stringr::str_c("LLMoutput/", dataframename, "/")
file_names <- base::list.files(filepath, full.names = TRUE)
gpt_labels <- base::rep(NA, base::length(file_names))
for (i in base::seq_along(file_names)){
response <- base::readRDS(file_names[i])
gpt_labels[i] <-
ifelse(
base::is.null(httr::content(response)$choices[[1]]$message$content),
NA, httr::content(response)$choices[[1]]$message$content)
}
gptoutput <- tibble::tibble(
id = stringr::str_replace(base::basename(file_names), "\\.rds$", ""),
relevant_gpt = gpt_labels
)
return(gptoutput)
}
get_response <- function(dataframe,model) {
dataframename <- base::deparse(base::substitute(dataframe))
filepath <- stringr::str_c("LLMoutput/", dataframename, "/", model, "/")
file_names <- base::list.files(filepath, full.names = TRUE)
gpt_labels <- base::rep(NA, base::length(file_names))
for (i in base::seq_along(file_names)){
response <- base::readRDS(file_names[i])
gpt_labels[i] <-
ifelse(
base::is.null(httr::content(response)$choices[[1]]$message$content),
NA, httr::content(response)$choices[[1]]$message$content)
}
gptoutput <- tibble::tibble(
id = stringr::str_replace(base::basename(file_names), "\\.rds$", ""),
relevant_gpt = gpt_labels
)
return(gptoutput)
}
get_response <- function(dataframe,model="mistral-7b-instruct") {
dataframename <- base::deparse(base::substitute(dataframe))
filepath <- stringr::str_c("LLMoutput/", dataframename, "/", model, "/")
file_names <- base::list.files(filepath, full.names = TRUE)
gpt_labels <- base::rep(NA, base::length(file_names))
for (i in base::seq_along(file_names)){
response <- base::readRDS(file_names[i])
gpt_labels[i] <-
ifelse(
base::is.null(httr::content(response)$choices[[1]]$message$content),
NA, httr::content(response)$choices[[1]]$message$content)
}
gptoutput <- tibble::tibble(
id = stringr::str_replace(base::basename(file_names), "\\.rds$", ""),
relevant_gpt = gpt_labels
)
return(gptoutput)
}
output <- get_response(my_data$text)
get_response <- function(column) {
columnname <- base::deparse(base::substitute(column))
filepath <- stringr::str_c("LLMoutput/", dataframename, "/", model, "/")
file_names <- base::list.files(filepath, full.names = TRUE)
gpt_labels <- base::rep(NA, base::length(file_names))
for (i in base::seq_along(file_names)){
response <- base::readRDS(file_names[i])
gpt_labels[i] <-
ifelse(
base::is.null(httr::content(response)$choices[[1]]$message$content),
NA, httr::content(response)$choices[[1]]$message$content)
}
gptoutput <- tibble::tibble(
id = stringr::str_replace(base::basename(file_names), "\\.rds$", ""),
annotated_text = gpt_labels
)
return(gptoutput)
}
output <- get_response(my_data$text)
get_response <- function(column, model = "mistral-7b-instruct") {
columnname <- base::deparse(base::substitute(column))
filepath <- stringr::str_c("LLMoutput/", columnname, "/", model, "/")
file_names <- base::list.files(filepath, full.names = TRUE)
gpt_labels <- base::rep(NA, base::length(file_names))
for (i in base::seq_along(file_names)){
response <- base::readRDS(file_names[i])
gpt_labels[i] <-
ifelse(
base::is.null(httr::content(response)$choices[[1]]$message$content),
NA, httr::content(response)$choices[[1]]$message$content)
}
gptoutput <- tibble::tibble(
id = stringr::str_replace(base::basename(file_names), "\\.rds$", ""),
annotated_text = gpt_labels
)
return(gptoutput)
}
output <- get_response(my_data$text)
perplexity_annotate <- function(column,
instruction = "Be precise and concise.",
api_key = Sys.getenv("perplexity_key"),
model = "mistral-7b-instruct",
api_url = "https://api.perplexity.ai/chat/completions") {
columnname <- deparse(substitute(column))
filepath <- paste0("LLMoutput/", columnname, "/", model, "/")
if (!dir.exists(filepath)) {
dir.create(filepath, recursive = TRUE)
}
print(paste("Writing RDS file to:", filepath))
result_df <- data.frame(id = character(), response = character(), stringsAsFactors = FALSE)
for (i in seq_along(column)) {
to_annotate_id <- i
to_annotate_text <- gsub("(\n|\r)", " ", column[i])
authorization <- paste0("Bearer ", api_key)
attempt <- 1
max_attempts <- 3
success <- FALSE
while (!success && attempt <= max_attempts) {
try({
response <- httr::POST(
url = api_url,
httr::add_headers(`Content-Type` = "application/json", `Authorization` = authorization),
encode = "json",
body = list(
model = model,
messages = list(
list(role = "system", content = instruction),
list(role = "user", content = to_annotate_text)
)
),
httr::timeout(5000)  # Correctly placed inside the POST function call
)
success <- TRUE
response_content <- content(response, "parsed")
message_content <- response_content$choices[[1]]$message$content
write_rds_path <- paste0(filepath, to_annotate_id, ".rds")
saveRDS(response, write_rds_path)
Sys.sleep(0.6)
message(i, " of ", length(column))
message("status_id: ", to_annotate_id, "\n", "instruction: ", instruction, "\n", "text: ", to_annotate_text)
message("Perplexity: ", message_content, "\n")
result_df <- rbind(result_df, data.frame(id = to_annotate_id, response = message_content, stringsAsFactors = FALSE))
}, silent = FALSE)
if (!success) {
Sys.sleep(2)
attempt <- attempt + 1
}
}
if (!success) {
stop("Failed to fetch data after ", max_attempts, " attempts.")
}
}
return(result_df)
}
output <- perplexity_annotate(my_data$text, instruction = "output the first few words of the text")
get_response <- function(column, model = "mistral-7b-instruct") {
columnname <- base::deparse(base::substitute(column))
filepath <- stringr::str_c("LLMoutput/", columnname, "/", model, "/")
file_names <- base::list.files(filepath, full.names = TRUE)
gpt_labels <- base::rep(NA, base::length(file_names))
for (i in base::seq_along(file_names)){
response <- base::readRDS(file_names[i])
gpt_labels[i] <-
ifelse(
base::is.null(httr::content(response)$choices[[1]]$message$content),
NA, httr::content(response)$choices[[1]]$message$content)
}
gptoutput <- tibble::tibble(
id = stringr::str_replace(base::basename(file_names), "\\.rds$", ""),
annotated_text = gpt_labels
)
return(gptoutput)
}
output <- get_response(my_data$text)
output <- get_response(my_data$text)
tag_perplexity <- function(column,
instruction = "Be precise and concise.",
api_key = base::Sys.getenv("perplexity_key"),
model = "mistral-7b-instruct",
api_url = "https://api.perplexity.ai/chat/completions") {
columnname <- base::deparse(base::substitute(column))
filepath <- stringr::paste0("LLMoutput/", columnname, "/", model, "/")
if (!base::dir.exists(filepath)) {
base::dir.create(filepath, recursive = TRUE)
}
base::print(base::paste("Writing RDS file to:", filepath))
result_df <- utils::data.frame(id = character(), response = character(), stringsAsFactors = FALSE)
for (i in base::seq_along(column)) {
to_annotate_id <- i
to_annotate_text <- base::gsub("(\n|\r)", " ", column[i])
authorization <- base::paste0("Bearer ", api_key)
attempt <- 1
max_attempts <- 3
success <- FALSE
while (!success && attempt <= max_attempts) {
try({
response <- httr::POST(
url = api_url,
httr::add_headers(`Content-Type` = "application/json", `Authorization` = authorization),
encode = "json",
body = list(
model = model,
messages = list(
list(role = "system", content = instruction),
list(role = "user", content = to_annotate_text)
)
),
httr::timeout(5000)  # Correctly placed inside the POST function call
)
success <- TRUE
response_content <- httr::content(response, "parsed")
message_content <- response_content$choices[[1]]$message$content
write_rds_path <- stringr::paste0(filepath, to_annotate_id, ".rds")
base::saveRDS(response, write_rds_path)
base::Sys.sleep(0.6)
base::message(i, " of ", base::length(column))
base::message("status_id: ", to_annotate_id, "\n", "instruction: ", instruction, "\n", "text: ", to_annotate_text)
base::message("Perplexity: ", message_content, "\n")
result_df <- utils::rbind(result_df, utils::data.frame(id = to_annotate_id, response = message_content, stringsAsFactors = FALSE))
}, silent = FALSE)
if (!success) {
base::Sys.sleep(2)
attempt <- attempt + 1
}
}
if (!success) {
base::stop("Failed to fetch data after ", max_attempts, " attempts.")
}
}
return(result_df)
}
output <- perplexity_annotate(my_data$text, instruction = "output the first few words of the text")
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
library(httr)
library(jsonlite)
library(dplyr)
tag_perplexity <- function(column,
instruction = "Be precise and concise.",
api_key = base::Sys.getenv("perplexity_key"),
model = "mistral-7b-instruct",
api_url = "https://api.perplexity.ai/chat/completions") {
columnname <- base::deparse(base::substitute(column))
filepath <- stringr::paste0("LLMoutput/", columnname, "/", model, "/")
if (!base::dir.exists(filepath)) {
base::dir.create(filepath, recursive = TRUE)
}
base::print(base::paste("Writing RDS file to:", filepath))
result_df <- utils::data.frame(id = character(), response = character(), stringsAsFactors = FALSE)
for (i in base::seq_along(column)) {
to_annotate_id <- i
to_annotate_text <- base::gsub("(\n|\r)", " ", column[i])
authorization <- base::paste0("Bearer ", api_key)
attempt <- 1
max_attempts <- 3
success <- FALSE
while (!success && attempt <= max_attempts) {
try({
response <- httr::POST(
url = api_url,
httr::add_headers(`Content-Type` = "application/json", `Authorization` = authorization),
encode = "json",
body = list(
model = model,
messages = list(
list(role = "system", content = instruction),
list(role = "user", content = to_annotate_text)
)
),
httr::timeout(5000)  # Correctly placed inside the POST function call
)
success <- TRUE
response_content <- httr::content(response, "parsed")
message_content <- response_content$choices[[1]]$message$content
write_rds_path <- stringr::paste0(filepath, to_annotate_id, ".rds")
base::saveRDS(response, write_rds_path)
base::Sys.sleep(0.6)
base::message(i, " of ", base::length(column))
base::message("status_id: ", to_annotate_id, "\n", "instruction: ", instruction, "\n", "text: ", to_annotate_text)
base::message("Perplexity: ", message_content, "\n")
result_df <- dplyr::rbind(result_df, utils::data.frame(id = to_annotate_id, response = message_content, stringsAsFactors = FALSE))
}, silent = FALSE)
if (!success) {
base::Sys.sleep(2)
attempt <- attempt + 1
}
}
if (!success) {
base::stop("Failed to fetch data after ", max_attempts, " attempts.")
}
}
return(result_df)
}
output <- perplexity_annotate(my_data$text, instruction = "output the first few words of the text")
Sys.setenv(perplexity_key="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")
my_data <- data.frame(
id = 1:3,
text = c("i am the best man in the world", "i am the worst man in the world", "i am an average man in the world")
)
library(httr)
library(stringr)
library(dplyr)
library(httr)
library(jsonlite)
library(dplyr)
tag_perplexity <- function(column,
instruction = "Be precise and concise.",
api_key = base::Sys.getenv("perplexity_key"),
model = "mistral-7b-instruct",
api_url = "https://api.perplexity.ai/chat/completions") {
columnname <- base::deparse(base::substitute(column))
filepath <- stringr::paste0("LLMoutput/", columnname, "/", model, "/")
if (!base::dir.exists(filepath)) {
base::dir.create(filepath, recursive = TRUE)
}
base::print(base::paste("Writing RDS file to:", filepath))
result_df <- utils::data.frame(id = character(), response = character(), stringsAsFactors = FALSE)
for (i in base::seq_along(column)) {
to_annotate_id <- i
to_annotate_text <- base::gsub("(\n|\r)", " ", column[i])
authorization <- base::paste0("Bearer ", api_key)
attempt <- 1
max_attempts <- 3
success <- FALSE
while (!success && attempt <= max_attempts) {
try({
response <- httr::POST(
url = api_url,
httr::add_headers(`Content-Type` = "application/json", `Authorization` = authorization),
encode = "json",
body = list(
model = model,
messages = list(
list(role = "system", content = instruction),
list(role = "user", content = to_annotate_text)
)
),
httr::timeout(5000)  # Correctly placed inside the POST function call
)
success <- TRUE
response_content <- httr::content(response, "parsed")
message_content <- response_content$choices[[1]]$message$content
write_rds_path <- stringr::paste0(filepath, to_annotate_id, ".rds")
base::saveRDS(response, write_rds_path)
base::Sys.sleep(0.6)
base::message(i, " of ", base::length(column))
base::message("status_id: ", to_annotate_id, "\n", "instruction: ", instruction, "\n", "text: ", to_annotate_text)
base::message("Perplexity: ", message_content, "\n")
result_df <- dplyr::rbind(result_df, utils::data.frame(id = to_annotate_id, response = message_content, stringsAsFactors = FALSE))
}, silent = FALSE)
if (!success) {
base::Sys.sleep(2)
attempt <- attempt + 1
}
}
if (!success) {
base::stop("Failed to fetch data after ", max_attempts, " attempts.")
}
}
return(result_df)
}
output <- perplexity_annotate(my_data$text, instruction = "output the first few words of the text")
output <- tag_perplexity(my_data$text, instruction = "output the first few words of the text")
tag_perplexity <- function(column,
instruction = "Be precise and concise.",
api_key = base::Sys.getenv("perplexity_key"),
model = "mistral-7b-instruct",
api_url = "https://api.perplexity.ai/chat/completions") {
columnname <- base::deparse(base::substitute(column))
filepath <- stringr::paste0("LLMoutput/", columnname, "/", model, "/")
if (!base::dir.exists(filepath)) {
base::dir.create(filepath, recursive = TRUE)
}
base::print(base::paste("Writing RDS file to:", filepath))
result_df <- utils::data.frame(id = character(), response = character(), stringsAsFactors = FALSE)
for (i in base::seq_along(column)) {
to_annotate_id <- i
to_annotate_text <- base::gsub("(\n|\r)", " ", column[i])
authorization <- base::paste0("Bearer ", api_key)
attempt <- 1
max_attempts <- 3
success <- FALSE
while (!success && attempt <= max_attempts) {
try({
response <- httr::POST(
url = api_url,
httr::add_headers(`Content-Type` = "application/json", `Authorization` = authorization),
encode = "json",
body = list(
model = model,
messages = list(
list(role = "system", content = instruction),
list(role = "user", content = to_annotate_text)
)
),
httr::timeout(5000)  # Correctly placed inside the POST function call
)
success <- TRUE
response_content <- httr::content(response, "parsed")
message_content <- response_content$choices[[1]]$message$content
write_rds_path <- stringr::paste0(filepath, to_annotate_id, ".rds")
base::saveRDS(response, write_rds_path)
base::Sys.sleep(0.6)
base::message(i, " of ", base::length(column))
base::message("status_id: ", to_annotate_id, "\n", "instruction: ", instruction, "\n", "text: ", to_annotate_text)
base::message("Perplexity: ", message_content, "\n")
result_df <- utils::rbind(result_df, utils::data.frame(id = to_annotate_id, response = message_content, stringsAsFactors = FALSE))
}, silent = FALSE)
if (!success) {
base::Sys.sleep(2)
attempt <- attempt + 1
}
}
if (!success) {
base::stop("Failed to fetch data after ", max_attempts, " attempts.")
}
}
return(result_df)
}
output <- tag_perplexity(my_data$text, instruction = "output the first few words of the text")
?paste0
devtools::document()
rm(list = c("tag_perplexity"))
devtools::document()
devtools::check()
devtools::document()
devtools::check()
?rbind
?data.frame
devtools::document()
devtools::check()
devtools::document()
devtools::check()
git remote -v
